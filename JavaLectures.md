"Промышленная разработка программ на Java"

# Лекция 1 "Вводная" (07.09.2020)
Разделение труда норма для промышленной разработки.
Java позволяет автоматизировать многие этапы разработки проекта.
В самом этапе разработки выделялись различные сферы.
	
Контейнеризация способствовала ускорению запуска приложений и продвижению микросервисной архитектуры.
	
Цели:
* Писать современные приложения на современных технологиях
* Научиться пользоваться инфраструктурой
	
Java - набор стандартов (jcp.org).
Инструменты:
* Средства для сборки

С программой поставляется:
* Программа
* Документация по использованию (пользователи) и описанию (администраторы)
* Документация по безопасности
* Инструкция по развертыванию
	
Ant, Maven, Gradle
	
Направления:
1. Изучение особенностей Java
1. Dependency injection
1. XML веб-сервисы, REST веб-сервисы
1. БД + Java
1. Методы авторизации и аутентификации

# Лекция 2 "Системы сборки" (14.09.2020)
Работа со сборщиками
Сначала был Ant (аналог make).
	
Системы сборки:
1. Императивные (Ant);
2. Декларативные (Maven, Gradle).
* Репозиторий артефактов (группа, идентификатор, версия, SCOPE (test, ...))
* Локальный
* Центральный
* Пользовательские
	
Сборка в Maven может  быть иерархической.
В профиле можно задать дополнительные зависимости.
	
Gradle
Код пишется не на Java, а на ... или Kotlin
Есть еще отличия, но за ними в документацию.

# Лекция 3 "Объекты, классы, сборщик мусора" (21.09.2020)
Классы круты. По описанию класса создаются объекты. Класс содержит в себе байт-код.
Class, Object, Interface.
Время жизни объекта:
Пока на него существует указатель + время на активацию сборщика мусора.
Сборщик мусора активизируется не часто. При его работе может быть использована стратегия stop the world (останавливается работа всех потоков). Есть и другие сборщики мусора с другими стратегиями.
Сборщик обладает корнем, с которого производит обход объектов. Все несвязанные области подлежат удалению.
	
Проблема утечки памяти:
1. Присваивание статической переменной большого поддерева ссылок. В этом случае удаления не будет.
2. Thread имеет ссылку на дерево объектов. У каждого объекта есть ссылка на поток. В этом случае поток обладает связью с корнем обхода, поэто объекты не удаляются.
Сборщик мусора также следит за дефрагментацией и старается ее убрать.
	
## Строки:
* String. Иммутабельна. Много лишних действий при выполнении операций.
* StringBuilder. Не потокобезопасный, но быстрый. 
* StringBuffer. Потокобезопасный, но медленне StringBuilder.
> Кодировки очень важны. Зачастую от них одни проблемы.
	
## Reflection:
Способ получения метаданных класса. Также можно вызывать методы и получать значения переменных.
Инициализаторы. Крутые штуки. Выполняются перед вызовом конструктора.
		
## Массивы:
Могут быть одномерными и многомерными. Почти как в С++ vector (тоже класс, тоже обладает полезными методами).
	
## Класслоадеры:
Классы загружаются динамически (в рантайме).

Pict1.drawio(Page-1).

# Лекция 4 "Класслоадеры"(28.09.2020)
Класс для загрузки классов. Загруженный класс обладает связью с загрузившим его класслоадером. То есть один и тот же класс, загруженный разными класслоадерами, являются разными классами. Это позволяет загружать классы во время выполнения приложения без необходимости его перекомпиляции. Система безопасности Java также модет быть настроена для конкретного класслоадера. В protection domain можно указать список разрешений/запретов на класслоадер. Аналогичное можно задать для конкретного класса.
	
## Принцип работы:
* defineClass
Из файла *.class создается объект Class.

* findClass
Выполняет непосредственный поиск

* loadClass
Для загрузки. Класс сначала ищется
	
Класслоадеры связаны древовидной иерархией друг с другом.
bootstrap (root) -> platform -> system
	
Искать класс необязательно. Например, он может генерироваться вместо поиска.
> Аспект ориентированное программирование. Стоит взглянуть.
	
Есть библиотеки для непосредственной работы с байткодом. Они позволяют добавлять и удалять методы, переменные и все что угодно.
	
У потока есть собственный класслоадер по умолчанию (не везде и не всегда).

Ресурсы класса: есть файлы, которые не являются *.class файлами, но необходимы для работы программы (xml, xsd, ...). 
	getResurseAsStream - загрузка файла из jar/папки получим поток на указанный файл.
		
## Inner classes
* Внутренние классы
* Анонимные внутренние классы
* Классы вложенные в методы
		
Закодить пример с анонимными классами
	
## Анонимные классы и зачем они нужны
Зависимости: при компиляции и при рантайме. Если зависимость на этапе компиляции, то это более сильная зависимость чем в райнтайме. Однако зависимости зачастую - это не очень здорово, так как теряется возможность простой замены компонентов или элементов, то есть уменьшаются возможности расширения. В идеале, чтобы можно было работать без прямых зависимостей.
> Интерфейсы позволяют решить эту проблему.

> Интерфейсы прям не просто так называются. Проще всего описать в своей джарке интерфейсы, с которыми мы хотим работать. После этого нам сделают конкретную имплементацию. Также у нас будет объект, собирающий все внешние сущности. В ней только методы для возврата необходимых интерфейсов. Через них и работаем.

Анонимные класс больше для удобства, чтобы меньше кодить. Так реально меньше. Это позволяет не добавлять прям отдельный класс в пакет.
Анонимные классы и замыкания - эквивалентные вещи (анонимные классы возможно проще отлаживать).
Замыкания:
* Параллельное программирование
* Stream API

# Лекция 5 "Generic" (05.10.2020)
Есть множество функций. В основном все было прозрачно, поэтому записей особо нет.

# Лекция 6 "Exception. Logger" (12.10.2020)
## Exception
Виды ошибок:  
- Полное уничтожение программы  
Выключить и снова включить. Детально рассматривать не будем
- Предусмотренные ошибки  
1. Возврат значения из функции  
Пусть из функции как-то возвращается код ошибки, по которому можно как-то получить текст ошибки. 0 - безошибочно. Все остальное - код ошибки.  
Существует дерево вызовов функций. Следовательно необходимо принять решение где и какие ошибки обрабатывать.  
Пример: С, часть С++
2. Exception  
Дальнейшее развитие - появление exception. В этом случае происходит переключение контекста, что является медленной операцией. Так что следует минимизировать ошибки, чтобы они вызывались действительно в крайних случаях.  
Пример Java  
- Непредусмотренные ошибки

### Механизм ошибок в Java
У методов указываются возможные exception при работе. Не рантайм exception хороши тем, что при их неправильном кодировании, программа нескомпилируется.
> Для прототипирования неплохо подходят языки с динамической типизацией. Для больших проектов лучше статическая типизация

Trouble class является прородителем всех классов ошибок в Java.  
CompileTime - Сборка и теперь еще и инициализация частей программы.  

try  
catch  
finally  

Также существует Stack Trace

#### Как правильно создавать exception
Пример плохой ситуации. Мы используем либу А. Она использует либу Б. В либе Б возникает ошибка и идет вверх, но нигде не обрабатывается. В итоге получается, что наш код получает exception, о котором мы ничего не знаем. В итоге создается еще одно исключение: ClassNotFound, что невозможно предусмотреть  

exceptionChain может быть решением. То есть все внутренние, которые возникают в либе Б, должны быть обернуты в либе А. Таким образом все возникаемые ошибки происходят в рамках логики либы А.  
Также стоит добавлять дополнительную информацию в исключения, чтобы было максимально просто понять в чем именно проблема и из-за чего она произошла.  
Например, если файл не был найден, то стоит добавить путь, в котором происходил поиск файла.  
Также следует трактовать все ошибки в рамках текущей предметной области. Например, мы ищем файл конфигурации. При возникновении ошибки, мы создаем ошибку ConfigNotFound, а не FileNotFound.

## Системы логирования
ЛогАПИ:  
- Сбор вызовов
- Сохранение вызовов
Логов может быть много. Очевидно, что логирование забирает часть ресурсов, что замедляет работу программы.  
Во втором поколении этапы были разделены. То есть лог сообщения записываются на диск блочно, а не сразу же.  
Библиотеки для логирования:  
1. Logger  
Встроенный. Малопопулярен.
2. Log4J  
Проседание производительности
3. Log4JV2.0  
Обратная совместимость + решение проблемы производительности V1.0. Сохранение по сети все равно проблематично.
4. LogBack(LogBag?)  
5. Другие

## Динамические прокси классы
Прокси-класс - класс, который заменяет собой вызов другого класса. То есть вместо вызова конечного класса вызывается прокси-класс.  
Mock class - фиктивные классы для подмены вызовов реальных классов.  
Способы создания прокси-классов:  
1. Создание прокси-класса (Proxy)  
class A implements InterfaceQ  
Данному классу передается метод и аргументы вызова.  
InvokationHandler с методом invoke(proxy, method, args[])  
2. Использовать библиотеку, позволяющую работать с proxy class  
- JavaAssistant
- CGLib  
> Попробовать закодить инструментацию класса (аннотации). Через Proxy класс
