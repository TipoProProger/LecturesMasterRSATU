"Промышленная разработка программ на Java"

# Лекция 1 "Вводная" (07.09.2020)
Разделение труда норма для промышленной разработки.
Java позволяет автоматизировать многие этапы разработки проекта.
В самом этапе разработки выделялись различные сферы.
	
Контейнеризация способствовала ускорению запуска приложений и продвижению микросервисной архитектуры.
	
Цели:
* Писать современные приложения на современных технологиях
* Научиться пользоваться инфраструктурой
	
Java - набор стандартов (jcp.org).
Инструменты:
* Средства для сборки

С программой поставляется:
* Программа
* Документация по использованию (пользователи) и описанию (администраторы)
* Документация по безопасности
* Инструкция по развертыванию
	
Ant, Maven, Gradle
	
Направления:
1. Изучение особенностей Java
1. Dependency injection
1. XML веб-сервисы, REST веб-сервисы
1. БД + Java
1. Методы авторизации и аутентификации

# Лекция 2 "Системы сборки" (14.09.2020)
Работа со сборщиками
Сначала был Ant (аналог make).
	
Системы сборки:
1. Императивные (Ant);
2. Декларативные (Maven, Gradle).
* Репозиторий артефактов (группа, идентификатор, версия, SCOPE (test, ...))
* Локальный
* Центральный
* Пользовательские
	
Сборка в Maven может  быть иерархической.
В профиле можно задать дополнительные зависимости.
	
Gradle
Код пишется не на Java, а на ... или Kotlin
Есть еще отличия, но за ними в документацию.

# Лекция 3 "Объекты, классы, сборщик мусора" (21.09.2020)
Классы круты. По описанию класса создаются объекты. Класс содержит в себе байт-код.
Class, Object, Interface.
Время жизни объекта:
Пока на него существует указатель + время на активацию сборщика мусора.
Сборщик мусора активизируется не часто. При его работе может быть использована стратегия stop the world (останавливается работа всех потоков). Есть и другие сборщики мусора с другими стратегиями.
Сборщик обладает корнем, с которого производит обход объектов. Все несвязанные области подлежат удалению.
	
Проблема утечки памяти:
1. Присваивание статической переменной большого поддерева ссылок. В этом случае удаления не будет.
2. Thread имеет ссылку на дерево объектов. У каждого объекта есть ссылка на поток. В этом случае поток обладает связью с корнем обхода, поэто объекты не удаляются.
Сборщик мусора также следит за дефрагментацией и старается ее убрать.
	
## Строки:
* String. Иммутабельна. Много лишних действий при выполнении операций.
* StringBuilder. Не потокобезопасный, но быстрый. 
* StringBuffer. Потокобезопасный, но медленне StringBuilder.
> Кодировки очень важны. Зачастую от них одни проблемы.
	
## Reflection:
Способ получения метаданных класса. Также можно вызывать методы и получать значения переменных.
Инициализаторы. Крутые штуки. Выполняются перед вызовом конструктора.
		
## Массивы:
Могут быть одномерными и многомерными. Почти как в С++ vector (тоже класс, тоже обладает полезными методами).
	
## Класслоадеры:
Классы загружаются динамически (в рантайме).

Pict1.drawio(Page-1).

# Лекция 4 "Класслоадеры"(28.09.2020)
Класс для загрузки классов. Загруженный класс обладает связью с загрузившим его класслоадером. То есть один и тот же класс, загруженный разными класслоадерами, являются разными классами. Это позволяет загружать классы во время выполнения приложения без необходимости его перекомпиляции. Система безопасности Java также модет быть настроена для конкретного класслоадера. В protection domain можно указать список разрешений/запретов на класслоадер. Аналогичное можно задать для конкретного класса.
	
## Принцип работы:
* defineClass
Из файла *.class создается объект Class.

* findClass
Выполняет непосредственный поиск

* loadClass
Для загрузки. Класс сначала ищется
	
Класслоадеры связаны древовидной иерархией друг с другом.
bootstrap (root) -> platform -> system
	
Искать класс необязательно. Например, он может генерироваться вместо поиска.
> Аспект ориентированное программирование. Стоит взглянуть.
	
Есть библиотеки для непосредственной работы с байткодом. Они позволяют добавлять и удалять методы, переменные и все что угодно.
	
У потока есть собственный класслоадер по умолчанию (не везде и не всегда).

Ресурсы класса: есть файлы, которые не являются *.class файлами, но необходимы для работы программы (xml, xsd, ...). 
	getResurseAsStream - загрузка файла из jar/папки получим поток на указанный файл.
		
## Inner classes
* Внутренние классы
* Анонимные внутренние классы
* Классы вложенные в методы
		
Закодить пример с анонимными классами
	
## Анонимные классы и зачем они нужны
Зависимости: при компиляции и при рантайме. Если зависимость на этапе компиляции, то это более сильная зависимость чем в райнтайме. Однако зависимости зачастую - это не очень здорово, так как теряется возможность простой замены компонентов или элементов, то есть уменьшаются возможности расширения. В идеале, чтобы можно было работать без прямых зависимостей.
> Интерфейсы позволяют решить эту проблему.

> Интерфейсы прям не просто так называются. Проще всего описать в своей джарке интерфейсы, с которыми мы хотим работать. После этого нам сделают конкретную имплементацию. Также у нас будет объект, собирающий все внешние сущности. В ней только методы для возврата необходимых интерфейсов. Через них и работаем.

Анонимные класс больше для удобства, чтобы меньше кодить. Так реально меньше. Это позволяет не добавлять прям отдельный класс в пакет.
Анонимные классы и замыкания - эквивалентные вещи (анонимные классы возможно проще отлаживать).
Замыкания:
* Параллельное программирование
* Stream API

# Лекция 5 "Generic" (05.10.2020)
Есть множество функций. В основном все было прозрачно, поэтому записей особо нет.

# Лекция 6 "Exception. Logger" (12.10.2020)
## Exception
Виды ошибок:  
- Полное уничтожение программы  
Выключить и снова включить. Детально рассматривать не будем
- Предусмотренные ошибки  
1. Возврат значения из функции  
Пусть из функции как-то возвращается код ошибки, по которому можно как-то получить текст ошибки. 0 - безошибочно. Все остальное - код ошибки.  
Существует дерево вызовов функций. Следовательно необходимо принять решение где и какие ошибки обрабатывать.  
Пример: С, часть С++
2. Exception  
Дальнейшее развитие - появление exception. В этом случае происходит переключение контекста, что является медленной операцией. Так что следует минимизировать ошибки, чтобы они вызывались действительно в крайних случаях.  
Пример Java  
- Непредусмотренные ошибки

### Механизм ошибок в Java
У методов указываются возможные exception при работе. Не рантайм exception хороши тем, что при их неправильном кодировании, программа нескомпилируется.
> Для прототипирования неплохо подходят языки с динамической типизацией. Для больших проектов лучше статическая типизация

Trouble class является прородителем всех классов ошибок в Java.  
CompileTime - Сборка и теперь еще и инициализация частей программы.  

try  
catch  
finally  

Также существует Stack Trace

#### Как правильно создавать exception
Пример плохой ситуации. Мы используем либу А. Она использует либу Б. В либе Б возникает ошибка и идет вверх, но нигде не обрабатывается. В итоге получается, что наш код получает exception, о котором мы ничего не знаем. В итоге создается еще одно исключение: ClassNotFound, что невозможно предусмотреть  

exceptionChain может быть решением. То есть все внутренние, которые возникают в либе Б, должны быть обернуты в либе А. Таким образом все возникаемые ошибки происходят в рамках логики либы А.  
Также стоит добавлять дополнительную информацию в исключения, чтобы было максимально просто понять в чем именно проблема и из-за чего она произошла.  
Например, если файл не был найден, то стоит добавить путь, в котором происходил поиск файла.  
Также следует трактовать все ошибки в рамках текущей предметной области. Например, мы ищем файл конфигурации. При возникновении ошибки, мы создаем ошибку ConfigNotFound, а не FileNotFound.

## Системы логирования
ЛогАПИ:  
- Сбор вызовов
- Сохранение вызовов
Логов может быть много. Очевидно, что логирование забирает часть ресурсов, что замедляет работу программы.  
Во втором поколении этапы были разделены. То есть лог сообщения записываются на диск блочно, а не сразу же.  
Библиотеки для логирования:  
1. Logger  
Встроенный. Малопопулярен.
2. Log4J  
Проседание производительности
3. Log4JV2.0  
Обратная совместимость + решение проблемы производительности V1.0. Сохранение по сети все равно проблематично.
4. LogBack(LogBag?)  
5. Другие

## Динамические прокси классы
Прокси-класс - класс, который заменяет собой вызов другого класса. То есть вместо вызова конечного класса вызывается прокси-класс.  
Mock class - фиктивные классы для подмены вызовов реальных классов.  
Способы создания прокси-классов:  
1. Создание прокси-класса (Proxy)  
class A implements InterfaceQ  
Данному классу передается метод и аргументы вызова.  
InvokationHandler с методом invoke(proxy, method, args[])  
2. Использовать библиотеку, позволяющую работать с proxy class  
- JavaAssistant
- CGLib  
> Попробовать закодить инструментацию класса (аннотации). Через Proxy класс

# Лекция 7 "Аннотации" (19.10.2020)
> Javassist. Рассмотрение того, как сделать класс
> Можно рабоать с байт-кодом классов. Например добавляя атрибуты. Детальней можно почитать на сайте https://www.codeflow.site/ru/article/javassist# или на сайте https://www.javassist.org/tutorial/tutorial.html
Общий список функций:  
1. Создать класс
2. Наследование класса
3. добавить имплементацию интерфейса
4. Добавить поля и методы (можно даже с параметарми)
5. Загрузить существующий класс
6. Модифицировать методы
7. Добавить аннотации
8. > По идее можно удалять данные


Можно создавать свои аннотации. При создании следует указывать аннотацию Retention (показывающая когда применять аннотацию (в райнтайме или при сборке)). Также следует указать Target. Он показывает к чему можно применять аннотацию.  
В целом, аннотации позволяют добавлять дополнительные метаданные к классу.  
> swagger-ui quarkus - это крутая и полезная вещь  
Действия готовых аннотаций описаны в документации.  
> JSR 365  
> Скорее всего в Quarkus сделано много через прокси классы  

> ! CDI лаба !

# Лекция 8 "Аутентификация в приложении" (26.10.2020)
TCP\UDP для передачи информации оп сети.
Способы аутентификации:
1. HTTPS (TLS) или SSL  
Ассимитричное шифрование. Приватный ключ для зашифровки, публичный ключ для дешифровки (можно и наоборот). Можно еще взять хеш от сообщения, зашифровать его. Это будет АЦП. Вместе с этой информацией можно проверять целостность и корректность сообщения.
> При симметричной ключ всего один  
Сервер отсылает свой сертификат клиенту. Если в сертификате доменное имя совпадает с доменом сервера, то сервер является тем, за кого себя выдает. Получаем ключ шифрования от сервера для установления безопасного канала связи.  
Двусторонне шифрование подразумевает, что у клиентов тоже есть сертификаты. Их валидность проверяет сервер.  
Аутентификация - выставление соответствия между клиентом и конкретным аккаунтом (распознавание).  
Авторизация - предоставление доступа к ресурсам в соответствии с правами аккаунта.  
Аутентифицировать через:
- Постоянное соединение через двусторонный HTTPS
- Создаем сессию на сервере  
Создается специальная структура для каждого пользователя. Проблема данного подхода в масштабируемости и ограниченности ресурсов сервера. С ресурсами все вроде прозрачно. Более детально следует рассмотреть вариант с балансировщиком. В этом случае на каждом сервере, к которому обращался клиент, будет создана сессия для него. При этом ресурсы сервера используются нерационально. Как вариант, можно создать еще один серер, который содержит все все сессии. Проблема с ресурсами сервера остается. Второй вариант решения проблемы - хранить сессию на клиенте в зашифрованном виде (или в подписанном). Больше всего похоже на идею токена. Токен выдается при входе в аккаунт, например при вводе логин/пароля. Инфа хранится либо в памяти, либо в куках. Токен обладает времене жизни.  
> После этого он превращается в тыкву  
2. HTTP  
- Basic  
Запрашиваем у сервера что-то. В заголовке запроса передается логин/пароль. При совпадении предоставляется доступ. Эта информация передается в теге authorization. Хранится в зашифрованном виде. Используется редко, так как не очень безопасна.
- Digest  
Логин + пароль + текущее время + некоторая соль. Потом считаем хеш этого. Передаем логин и текущее время и соль и хеш. Сервер по этой информации строит свой хеш. Они должны совпасть. Недостатком является то, что позволяет только аутентифицироваться, но не может передавать дополнительную информацию.
- JWT  
Токен в виде JSON. В JSON передаются заголовки и данные (PAYLOAD). Можно добавить и свою информацию. Созданный токен передается клиенту. Далее он прикладывается ко всем запросам.
- OAuth2  
- OpenID Connect  
Клиент, сервер, idp. В данном случае сервер будет выступать клиентом Idp. Пользоватль присылает на сервер запрос. Сервер вынуждает пользователя зайти на Idp сервер для прохождения аутентификации. После этого пользователя возвращает на сервер уже с access токеном и с refresh токеном. Access токен передается серверу. Refresh токен для получения нового токена от Idp сервера. Сервер при необходимости может обращаться к Idp серверу при необходимости получения дополнительной информации.

KeyCloak сервер
> Настроить keyCloak сервер по умолчанию

# Лекция 8 "Основные моменты приложения" (02.11.2020)
Сервлет - RFC2616  
URL - читай стандарт  
Над TCP слушателем HTTP слушатель, над которым REST слушатель  
Есть еще GraphQL  
Работа с данными (БД)  
JDBC драйвер. Требуется строка, содержащая настройки подключения к БД  
>Liquibase https://www.liquibase.org/get-started/how-liquibase-works  
Есть подготовленные запросы и запросы сразу для исполнения. Первые сначала компилируются, потом исполняются. За счет этого можно выполнить один и тот же запрос несколько раз с разными параметрами.  

При подключении к базу устанавливается TCP соединение. Зачастую установка соединения более длительная операция, чем выполнение самого запроса. Поэтому существует пул коннектов. Передается уже готовый объект соединения. Это позволяет ускорить.  
Построители SQL запросов
>https://quarkus.io/guides/reactive-sql-clients
