"Промышленная разработка программ на Java"

# Лекция 1 "Вводная" (07.09.2020)
Разделение труда норма для промышленной разработки.
Java позволяет автоматизировать многие этапы разработки проекта.
В самом этапе разработки выделялись различные сферы.
	
Контейнеризация способствовала ускорению запуска приложений и продвижению микросервисной архитектуры.
	
Цели:
* Писать современные приложения на современных технологиях
* Научиться пользоваться инфраструктурой
	
Java - набор стандартов (jcp.org).
Инструменты:
* Средства для сборки

С программой поставляется:
* Программа
* Документация по использованию (пользователи) и описанию (администраторы)
* Документация по безопасности
* Инструкция по развертыванию
	
Ant, Maven, Gradle
	
Направления:
1. Изучение особенностей Java
1. Dependency injection
1. XML веб-сервисы, REST веб-сервисы
1. БД + Java
1. Методы авторизации и аутентификации

# Лекция 2 "Системы сборки" (14.09.2020)
Работа со сборщиками
Сначала был Ant (аналог make).
	
Системы сборки:
1. Императивные (Ant);
2. Декларативные (Maven, Gradle).
* Репозиторий артефактов (группа, идентификатор, версия, SCOPE (test, ...))
* Локальный
* Центральный
* Пользовательские
	
Сборка в Maven может  быть иерархической.
В профиле можно задать дополнительные зависимости.
	
Gradle
Код пишется не на Java, а на ... или Kotlin
Есть еще отличия, но за ними в документацию.

# Лекция 3 "Объекты, классы, сборщик мусора" (21.09.2020)
Классы круты. По описанию класса создаются объекты. Класс содержит в себе байт-код.
Class, Object, Interface.
Время жизни объекта:
Пока на него существует указатель + время на активацию сборщика мусора.
Сборщик мусора активизируется не часто. При его работе может быть использована стратегия stop the world (останавливается работа всех потоков). Есть и другие сборщики мусора с другими стратегиями.
Сборщик обладает корнем, с которого производит обход объектов. Все несвязанные области подлежат удалению.
	
Проблема утечки памяти:
1. Присваивание статической переменной большого поддерева ссылок. В этом случае удаления не будет.
2. Thread имеет ссылку на дерево объектов. У каждого объекта есть ссылка на поток. В этом случае поток обладает связью с корнем обхода, поэто объекты не удаляются.
Сборщик мусора также следит за дефрагментацией и старается ее убрать.
	
## Строки:
* String. Иммутабельна. Много лишних действий при выполнении операций.
* StringBuilder. Не потокобезопасный, но быстрый. 
* StringBuffer. Потокобезопасный, но медленне StringBuilder.
> Кодировки очень важны. Зачастую от них одни проблемы.
	
## Reflection:
Способ получения метаданных класса. Также можно вызывать методы и получать значения переменных.
Инициализаторы. Крутые штуки. Выполняются перед вызовом конструктора.
		
## Массивы:
Могут быть одномерными и многомерными. Почти как в С++ vector (тоже класс, тоже обладает полезными методами).
	
## Класслоадеры:
Классы загружаются динамически (в рантайме).

Pict1.drawio(Page-1).

# Лекция 4 "Класслоадеры"(28.09.2020)
Класс для загрузки классов. Загруженный класс обладает связью с загрузившим его класслоадером. То есть один и тот же класс, загруженный разными класслоадерами, являются разными классами. Это позволяет загружать классы во время выполнения приложения без необходимости его перекомпиляции. Система безопасности Java также модет быть настроена для конкретного класслоадера. В protection domain можно указать список разрешений/запретов на класслоадер. Аналогичное можно задать для конкретного класса.
	
## Принцип работы:
* defineClass
Из файла *.class создается объект Class.

* findClass
Выполняет непосредственный поиск

* loadClass
Для загрузки. Класс сначала ищется
	
Класслоадеры связаны древовидной иерархией друг с другом.
bootstrap (root) -> platform -> system
	
Искать класс необязательно. Например, он может генерироваться вместо поиска.
> Аспект ориентированное программирование. Стоит взглянуть.
	
Есть библиотеки для непосредственной работы с байткодом. Они позволяют добавлять и удалять методы, переменные и все что угодно.
	
У потока есть собственный класслоадер по умолчанию (не везде и не всегда).

Ресурсы класса: есть файлы, которые не являются *.class файлами, но необходимы для работы программы (xml, xsd, ...). 
	getResurseAsStream - загрузка файла из jar/папки получим поток на указанный файл.
		
## Inner classes
* Внутренние классы
* Анонимные внутренние классы
* Классы вложенные в методы
		
Закодить пример с анонимными классами
	
## Анонимные классы и зачем они нужны
Зависимости: при компиляции и при рантайме. Если зависимость на этапе компиляции, то это более сильная зависимость чем в райнтайме. Однако зависимости зачастую - это не очень здорово, так как теряется возможность простой замены компонентов или элементов, то есть уменьшаются возможности расширения. В идеале, чтобы можно было работать без прямых зависимостей.
> Интерфейсы позволяют решить эту проблему.

> Интерфейсы прям не просто так называются. Проще всего описать в своей джарке интерфейсы, с которыми мы хотим работать. После этого нам сделают конкретную имплементацию. Также у нас будет объект, собирающий все внешние сущности. В ней только методы для возврата необходимых интерфейсов. Через них и работаем.

Анонимные класс больше для удобства, чтобы меньше кодить. Так реально меньше. Это позволяет не добавлять прям отдельный класс в пакет.
Анонимные классы и замыкания - эквивалентные вещи (анонимные классы возможно проще отлаживать).
Замыкания:
* Параллельное программирование
* Stream API

# Лекция 3 "Generic" (05.10.2020)
Есть множество функций. В основном все было прозрачно, поэтому записей особо нет.
